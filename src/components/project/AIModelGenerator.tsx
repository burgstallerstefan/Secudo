'use client';

import { useState } from 'react';
import Button from '@/components/common/Button';

interface GeneratedNode {
  id: string;
  label: string;
  type: 'System' | 'Component' | 'Human';
  parentId?: string;
}

interface GeneratedEdge {
  id: string;
  from: string;
  to: string;
  direction: 'A_TO_B' | 'B_TO_A' | 'BIDIRECTIONAL';
  name?: string;
  protocol?: string;
}

interface GeneratedDataObject {
  id: string;
  name: string;
  dataClass:
    | 'Credentials'
    | 'PersonalData'
    | 'SafetyRelevant'
    | 'ProductionData'
    | 'Telemetry'
    | 'Logs'
    | 'IntellectualProperty'
    | 'Configuration'
    | 'Other';
  description?: string;
}

interface GeneratedComponentData {
  nodeId: string;
  dataObjectId: string;
  role: 'Stores' | 'Processes' | 'Generates' | 'Receives';
}

interface GeneratedEdgeDataFlow {
  edgeId: string;
  dataObjectId: string;
  direction: 'SourceToTarget' | 'TargetToSource' | 'Bidirectional';
}

interface GenerationResult {
  success: boolean;
  nodes: GeneratedNode[];
  edges: GeneratedEdge[];
  dataObjects: GeneratedDataObject[];
  componentData: GeneratedComponentData[];
  edgeDataFlows: GeneratedEdgeDataFlow[];
  provider?: 'ollama' | 'fallback';
  model?: string;
  fallbackUsed?: boolean;
  warning?: string;
  error?: string;
}

interface AIModelGeneratorProps {
  projectId: string;
  onImported?: () => Promise<void> | void;
}

function normalizeDirectionSymbol(direction: GeneratedEdge['direction']): string {
  if (direction === 'BIDIRECTIONAL') {
    return '<->';
  }
  if (direction === 'B_TO_A') {
    return '<-';
  }
  return '->';
}

export default function AIModelGenerator({ projectId, onImported }: AIModelGeneratorProps) {
  const [textInput, setTextInput] = useState('');
  const [isBusy, setIsBusy] = useState(false);
  const [result, setResult] = useState<GenerationResult | null>(null);
  const [error, setError] = useState('');
  const [warning, setWarning] = useState('');
  const [showPreview, setShowPreview] = useState(false);
  const handleGenerate = async () => {
    if (!textInput.trim()) {
      setError('Please enter a system description.');
      return;
    }

    try {
      setIsBusy(true);
      setError('');
      setWarning('');
      setResult(null);

      const response = await fetch(`/api/projects/${projectId}/ai/model-from-text`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ systemDescription: textInput.trim() }),
      });

      const payload = (await response.json()) as Partial<GenerationResult> & { error?: string };
      if (!response.ok || !payload.success) {
        throw new Error(payload.error || 'Generation failed');
      }

      const normalizedResult: GenerationResult = {
        success: true,
        nodes: payload.nodes || [],
        edges: payload.edges || [],
        dataObjects: payload.dataObjects || [],
        componentData: payload.componentData || [],
        edgeDataFlows: payload.edgeDataFlows || [],
        provider: payload.provider,
        model: payload.model,
        fallbackUsed: payload.fallbackUsed,
        warning: payload.warning,
      };
      setResult(normalizedResult);
      if (payload.warning) {
        setWarning(payload.warning);
      }
      setShowPreview(true);
    } catch (generationError) {
      setError((generationError as Error).message);
    } finally {
      setIsBusy(false);
    }
  };

  const handleImportModel = async () => {
    if (!result?.success) {
      setError('No generated model available.');
      return;
    }

    try {
      setIsBusy(true);
      setError('');
      setWarning('');

      const generatedToPersistedNodeId = new Map<string, string>();
      const generatedToPersistedEdgeId = new Map<string, string>();
      const generatedToPersistedDataObjectId = new Map<string, string>();

      const pendingNodes = [...result.nodes];
      let importGuard = pendingNodes.length + 5;
      while (pendingNodes.length > 0 && importGuard > 0) {
        let importedInPass = 0;
        const remaining: GeneratedNode[] = [];

        for (const node of pendingNodes) {
          const parentGeneratedId = node.parentId?.trim();
          const resolvedParentNodeId = parentGeneratedId
            ? generatedToPersistedNodeId.get(parentGeneratedId)
            : undefined;

          if (parentGeneratedId && !resolvedParentNodeId) {
            remaining.push(node);
            continue;
          }

          const nodeResponse = await fetch(`/api/projects/${projectId}/nodes`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name: node.label,
              category: node.type === 'System' ? 'Container' : 'Component',
              description: 'Generated by AI model assistant',
              parentNodeId: resolvedParentNodeId || null,
            }),
          });

          if (!nodeResponse.ok) {
            const payload = (await nodeResponse.json().catch(() => ({}))) as { error?: string };
            throw new Error(payload.error || `Node "${node.label}" could not be imported`);
          }

          const persistedNode = (await nodeResponse.json()) as { id: string };
          generatedToPersistedNodeId.set(node.id, persistedNode.id);
          importedInPass += 1;
        }

        if (importedInPass === 0 && remaining.length > 0) {
          const unresolved = remaining.map((node) => node.label).join(', ');
          throw new Error(`Nodes could not be imported due to unresolved parent references: ${unresolved}`);
        }

        pendingNodes.length = 0;
        pendingNodes.push(...remaining);
        importGuard -= 1;
      }

      if (pendingNodes.length > 0) {
        throw new Error('Node import did not finish (cyclic or invalid parent references).');
      }

      let skippedEdges = 0;
      for (const edge of result.edges) {
        const sourceNodeId = generatedToPersistedNodeId.get(edge.from);
        const targetNodeId = generatedToPersistedNodeId.get(edge.to);

        if (!sourceNodeId || !targetNodeId) {
          skippedEdges += 1;
          continue;
        }

        const edgeResponse = await fetch(`/api/projects/${projectId}/edges`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sourceNodeId,
            targetNodeId,
            direction: edge.direction,
            name: edge.name || 'AI generated connection',
            protocol: edge.protocol || 'Generated',
          }),
        });

        if (!edgeResponse.ok) {
          const payload = (await edgeResponse.json().catch(() => ({}))) as { error?: string };
          throw new Error(payload.error || 'One or more edges could not be imported');
        }

        const persistedEdge = (await edgeResponse.json()) as { id: string };
        generatedToPersistedEdgeId.set(edge.id, persistedEdge.id);
      }

      for (const dataObject of result.dataObjects) {
        const response = await fetch(`/api/projects/${projectId}/data-objects`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: dataObject.name,
            dataClass: dataObject.dataClass,
            description: dataObject.description || 'Generated by AI model assistant',
          }),
        });

        if (!response.ok) {
          const payload = (await response.json().catch(() => ({}))) as { error?: string };
          throw new Error(payload.error || `Data object "${dataObject.name}" could not be imported`);
        }

        const persisted = (await response.json()) as { id: string };
        generatedToPersistedDataObjectId.set(dataObject.id, persisted.id);
      }

      let skippedComponentData = 0;
      for (const mapping of result.componentData) {
        const nodeId = generatedToPersistedNodeId.get(mapping.nodeId);
        const dataObjectId = generatedToPersistedDataObjectId.get(mapping.dataObjectId);
        if (!nodeId || !dataObjectId) {
          skippedComponentData += 1;
          continue;
        }

        const response = await fetch(`/api/projects/${projectId}/component-data`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            nodeId,
            dataObjectId,
            role: mapping.role,
          }),
        });

        if (!response.ok) {
          skippedComponentData += 1;
        }
      }

      let skippedEdgeDataFlows = 0;
      for (const mapping of result.edgeDataFlows) {
        const edgeId = generatedToPersistedEdgeId.get(mapping.edgeId);
        const dataObjectId = generatedToPersistedDataObjectId.get(mapping.dataObjectId);
        if (!edgeId || !dataObjectId) {
          skippedEdgeDataFlows += 1;
          continue;
        }

        const response = await fetch(`/api/projects/${projectId}/edge-data-flows`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            edgeId,
            dataObjectId,
            direction: mapping.direction,
          }),
        });

        if (!response.ok) {
          skippedEdgeDataFlows += 1;
        }
      }

      setTextInput('');
      setResult(null);
      setShowPreview(false);

      const warningParts: string[] = [];
      if (skippedEdges > 0) {
        warningParts.push(`${skippedEdges} connection(s) skipped`);
      }
      if (skippedComponentData > 0) {
        warningParts.push(`${skippedComponentData} component-data mapping(s) skipped`);
      }
      if (skippedEdgeDataFlows > 0) {
        warningParts.push(`${skippedEdgeDataFlows} edge-data-flow mapping(s) skipped`);
      }
      if (warningParts.length > 0) {
        setWarning(`Import finished with warnings: ${warningParts.join('; ')}.`);
      }

      if (onImported) {
        await onImported();
      }
    } catch (importError) {
      setError((importError as Error).message);
    } finally {
      setIsBusy(false);
    }
  };

  return (
    <div className="space-y-6">
      {error && <div className="rounded border border-red-600/40 bg-red-900/20 p-3 text-sm text-red-200">{error}</div>}
      {warning && <div className="rounded border border-yellow-600/40 bg-yellow-900/20 p-3 text-sm text-yellow-100">{warning}</div>}

      <div className="space-y-3">
        <label className="block text-sm font-semibold text-white">System Description</label>
        <p className="mb-2 text-xs text-slate-400">
          Describe components and interactions in natural language. AI will generate a candidate model.
        </p>

        <textarea
          value={textInput}
          onChange={(event) => setTextInput(event.target.value)}
          placeholder="Beschreibe Container, Komponenten und Datenfluss in natÃ¼rlicher Sprache."
          className="h-32 w-full resize-none rounded-lg border border-slate-600 bg-slate-700/50 p-3 font-mono text-sm text-white placeholder-slate-500 focus:border-orange-400 focus:outline-none focus:ring-1 focus:ring-orange-400/20"
        />

        <div className="flex gap-2">
          <Button onClick={handleGenerate} disabled={isBusy || !textInput.trim()}>
            {isBusy ? 'Analyzing...' : 'Generate Model'}
          </Button>

          {result?.success && (
            <button
              onClick={() => setShowPreview((prev) => !prev)}
              className="rounded-lg bg-slate-700 px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-slate-600"
              type="button"
            >
              {showPreview ? 'Hide Preview' : 'Show Preview'}
            </button>
          )}
        </div>
      </div>

      {showPreview && result?.success && (
        <div className="space-y-4 rounded-lg border border-slate-700 bg-slate-800/50 p-6">
          <h3 className="text-lg font-semibold text-white">Model Preview</h3>
          <div className="rounded border border-slate-700/80 bg-slate-900/40 p-3 text-xs text-slate-300">
            <p>
              Provider: <span className="font-semibold text-slate-100">{result.provider || 'unknown'}</span>
              {result.model ? <span> / Model: <span className="font-semibold text-slate-100">{result.model}</span></span> : null}
            </p>
            <p className="mt-1 text-slate-400">
              {result.fallbackUsed
                ? 'Fallback parsing was used because Ollama was unavailable or returned invalid output.'
                : 'Generated with Ollama JSON mode.'}
            </p>
          </div>

          <div>
            <p className="mb-2 text-sm font-semibold text-slate-300">Components ({result.nodes.length})</p>
            <div className="grid grid-cols-1 gap-2 md:grid-cols-2">
              {result.nodes.map((node) => (
                <div key={node.id} className="rounded border-l-2 border-orange-400 bg-slate-700/50 px-3 py-2">
                  <p className="text-sm font-medium text-white">{node.label}</p>
                  <p className="text-xs text-slate-400">{node.type === 'System' ? 'Container' : 'Component'}</p>
                </div>
              ))}
            </div>
          </div>

          {result.edges.length > 0 && (
            <div>
              <p className="mb-2 text-sm font-semibold text-slate-300">Connections ({result.edges.length})</p>
              <div className="space-y-1 text-xs text-slate-300">
                {result.edges.map((edge, index) => {
                  const fromLabel = result.nodes.find((node) => node.id === edge.from)?.label || edge.from;
                  const toLabel = result.nodes.find((node) => node.id === edge.to)?.label || edge.to;
                  return (
                    <div key={`${edge.from}-${edge.to}-${index}`} className="font-mono">
                      {fromLabel} {normalizeDirectionSymbol(edge.direction)} {toLabel}
                      {edge.protocol ? ` (${edge.protocol})` : ''}
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          {result.dataObjects.length > 0 && (
            <div>
              <p className="mb-2 text-sm font-semibold text-slate-300">Data Objects ({result.dataObjects.length})</p>
              <div className="space-y-1 text-xs text-slate-300">
                {result.dataObjects.map((dataObject) => (
                  <div key={dataObject.id}>
                    {dataObject.name} <span className="text-slate-500">[{dataObject.dataClass}]</span>
                  </div>
                ))}
              </div>
            </div>
          )}

          {result.edgeDataFlows.length > 0 && (
            <div>
              <p className="mb-2 text-sm font-semibold text-slate-300">Data Flows ({result.edgeDataFlows.length})</p>
              <div className="space-y-1 text-xs text-slate-300">
                {result.edgeDataFlows.map((flow, index) => {
                  const edge = result.edges.find((candidate) => candidate.id === flow.edgeId);
                  const dataObject = result.dataObjects.find((candidate) => candidate.id === flow.dataObjectId);
                  const fromLabel = edge
                    ? result.nodes.find((node) => node.id === edge.from)?.label || edge.from
                    : flow.edgeId;
                  const toLabel = edge
                    ? result.nodes.find((node) => node.id === edge.to)?.label || edge.to
                    : flow.edgeId;
                  const flowDirection =
                    flow.direction === 'TargetToSource'
                      ? 'B_TO_A'
                      : flow.direction === 'Bidirectional'
                        ? 'BIDIRECTIONAL'
                        : edge?.direction || 'A_TO_B';
                  return (
                    <div key={`${flow.edgeId}-${flow.dataObjectId}-${index}`}>
                      {dataObject?.name || flow.dataObjectId}: {fromLabel}{' '}
                      {normalizeDirectionSymbol(flowDirection)} {toLabel}
                    </div>
                  );
                })}
              </div>
            </div>
          )}

          <div className="border-t border-slate-700 pt-4">
            <button
              onClick={handleImportModel}
              disabled={isBusy}
              className="w-full rounded-lg bg-gradient-to-r from-orange-500 to-yellow-500 px-4 py-2 font-semibold text-slate-900 transition-all hover:from-orange-600 hover:to-yellow-600 disabled:opacity-60"
              type="button"
            >
              {isBusy ? 'Importing...' : 'Import Into Project'}
            </button>
          </div>
        </div>
      )}

    </div>
  );
}
